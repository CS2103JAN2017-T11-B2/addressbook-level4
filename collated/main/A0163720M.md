# A0163720M
###### \java\seedu\todolist\logic\commands\AddCommand.java
``` java
    /**
     * Creates an AddCommand using raw values to create a todo with start time and end time (event)
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public AddCommand(String todo, Optional<String> startTime,
            Optional<String> endTime, Set<String> tags) throws IllegalValueException {
        try {
            // Parse through the set of tags
            final Set<Tag> tagSet = new HashSet<>();
            for (String tagName : tags) {
                tagSet.add(new Tag(tagName));
            }

            // Check for existence of each of the fields
            Name name = (todo != null) ? new Name(todo) : null;
            Date start;
            if (startTime.isPresent()) {
                start =  (!startTime.get().isEmpty()) ?
                        StringUtil.parseDate(startTime.get() , DATE_FORMAT) :
                            StringUtil.parseDate(DEFAULT_ADD_STARTTIME , DATE_FORMAT);
            } else {
                start = null;
            }

            Date end;
            if (endTime.isPresent()) {
                end =  (!endTime.get().isEmpty()) ?
                        StringUtil.parseDate(endTime.get() , DATE_FORMAT) :
                            StringUtil.parseDate(DEFAULT_ADD_ENDTIME , DATE_FORMAT);
            } else {
                end = null;
            }

            UniqueTagList tagList = new UniqueTagList(tagSet);

            // Todo(name, start_time, end_time, complete_time, taglist)
            this.toAdd = new Todo(name, start, end, null, tagList);
        } catch (IllegalValueException e) {
            throw e;
        }
    }
```
###### \java\seedu\todolist\logic\commands\AddCommand.java
``` java
    /**
     * Creates an AddCommand using raw values to create a todo with just the end time (deadline)
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public AddCommand(String todo, Optional<String> endTime, Set<String> tags) throws IllegalValueException {
        // Cannot throw an exception since there's only one line in the constructor
        // and the first line must be the call to the constructor, not try{}
        this(todo, Optional.empty(), endTime, tags);
    }
```
###### \java\seedu\todolist\logic\commands\AddCommand.java
``` java
    /**
     * Creates an AddCommand using raw values to create a floating task
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public AddCommand(String todo, Set<String> tags) throws IllegalValueException {
        // Cannot throw an exception since there's only one line in the constructor and the first line cannot be try{}
        this(todo, Optional.empty(), Optional.empty(), tags);
    }

    @Override
    public CommandResult execute() throws CommandException {
        assert model != null;
        try {
            model.addTodo(toAdd);
            return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd));
        } catch (UniqueTodoList.DuplicateTodoException e) {
            throw new CommandException(MESSAGE_DUPLICATE_TODO);
        }
    }
}
```
###### \java\seedu\todolist\logic\commands\FindCommand.java
``` java
    /**
     * Creates a FindCommand with tags as parameters
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public FindCommand(UniqueTagList tags) {
        this.tags = tags;
    }
```
###### \java\seedu\todolist\logic\commands\FindCommand.java
``` java
    @Override
    public CommandResult execute() {
        if (this.tags != null) {
            model.updateFilteredTodoList(tags);
        } else {
            model.updateFilteredTodoList(keywords);
        }

        return new CommandResult(getMessageForTodoListShownSummary(model.getFilteredTodoList().size()));
    }
```
###### \java\seedu\todolist\logic\commands\SaveFileCommand.java
``` java
package seedu.todolist.logic.commands;

import java.io.File;
import java.io.IOException;

import seedu.todolist.commons.core.Config;
import seedu.todolist.commons.core.Messages;
import seedu.todolist.commons.exceptions.DataConversionException;
import seedu.todolist.commons.util.ConfigUtil;
import seedu.todolist.logic.commands.exceptions.CommandException;
import seedu.todolist.storage.StorageManager;

public class SaveFileCommand extends Command {
    private String saveFilePath;
    public static final String MESSAGE_CONFIG_ERROR = "Error handling the config file.";
    public static final String MESSAGE_SUCCESS = "Save file updated!";
    public static final String COMMAND_WORD = "savefile";
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Updates the save file location.\n"
            + "Parameters: PATH (must be a valid path string pointing to existing .xml file)\n" + "Example: "
            + COMMAND_WORD + " data/newtodolist.xml";

    public SaveFileCommand(String saveFilePath) {
        this.saveFilePath = saveFilePath;
    }

    @Override
    public CommandResult execute() throws CommandException {
        File f = new File(saveFilePath);

        if (!f.exists() || f.isDirectory()) {
            throw new CommandException(Messages.MESSAGE_FILE_NOT_FOUND);
        }

        try {
            // There should only be one instance of config each session - grab a
            // handle on that specific one
            Config config = ConfigUtil.readConfig(Config.DEFAULT_CONFIG_FILE).get();
            String todoListFilePath = config.getTodoListFilePath();
            String userPrefsFilePath = config.getUserPrefsFilePath();
            StorageManager storageManager = new StorageManager(todoListFilePath,  userPrefsFilePath);
            storageManager.updateSaveFilePath(saveFilePath);
            return new CommandResult(MESSAGE_SUCCESS);
        } catch (DataConversionException e) {
            // Catch for data conversion from Optional<Config> to Config
            throw new CommandException(MESSAGE_CONFIG_ERROR);
        } catch (IOException e) {
            throw new CommandException(Messages.MESSAGE_FILE_NOT_FOUND);
        }
    }
}
```
###### \java\seedu\todolist\logic\parser\AddCommandParser.java
``` java
    /**
     * Parses the given {@code String} of arguments in the context of the AddCommand
     * and returns an AddCommand object for execution.
     */
    public Command parse(String args) {
        ArgumentTokenizer argsTokenizer =
                new ArgumentTokenizer(PREFIX_START_TIME, PREFIX_END_TIME, PREFIX_TAG);
        argsTokenizer.tokenize(args);
        try {
            Optional<String> startTime = argsTokenizer.getValue(PREFIX_START_TIME);
            Optional<String> endTime = argsTokenizer.getValue(PREFIX_END_TIME);

            if (startTime.isPresent() && endTime.isPresent()) {
                return new AddCommand (
                        argsTokenizer.getPreamble().get(),
                        startTime,
                        endTime,
                        ParserUtil.toSet(argsTokenizer.getAllValues(PREFIX_TAG))
                );
            } else if (endTime.isPresent() && !startTime.isPresent()) {
                return new AddCommand(
                        argsTokenizer.getPreamble().get(),
                        endTime,
                        ParserUtil.toSet(argsTokenizer.getAllValues(PREFIX_TAG))
                );
            } else {
                return new AddCommand(
                        argsTokenizer.getPreamble().get(),
                        ParserUtil.toSet(argsTokenizer.getAllValues(PREFIX_TAG))
                );
            }

        } catch (NoSuchElementException nsee) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }
```
###### \java\seedu\todolist\logic\parser\FindCommandParser.java
``` java
    /**
     * Parses the given {@code String} of arguments in the context of the FindCommand
     * and returns an FindCommand object for execution.
     * @throws IllegalValueException
     */
    public Command parse(String args) {
        ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(CliSyntax.PREFIX_TAG);
        argsTokenizer.tokenize(args);
        // Fetch the keyword string before the prefix
        Optional<String> keywordsString = argsTokenizer.getPreamble();

        // User must enter either the search keyword or parameters with which to search
        if (!keywordsString.isPresent() && !argsTokenizer.getAllValues(CliSyntax.PREFIX_TAG).isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, FindCommand.MESSAGE_USAGE));
        }

        try {
            if (keywordsString.isPresent()) {
                final String[] keywords = keywordsString.get().split("\\s+");
                final Set<String> keywordsSet = new HashSet<>(Arrays.asList(keywords));

                return new FindCommand(keywordsSet);
            } else {
                // Store the individual tag strings in a set
                final Set<String> tagsStrings = ParserUtil.toSet(argsTokenizer.getAllValues(CliSyntax.PREFIX_TAG));
                final Set<Tag> tagsSet = new HashSet<>();

                for (String tagName : tagsStrings) {
                    tagsSet.add(new Tag(tagName));
                }

                final UniqueTagList uniqueTagList = new UniqueTagList(tagsSet);

                return new FindCommand(uniqueTagList);
            }
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }
```
###### \java\seedu\todolist\logic\parser\SaveFileCommandParser.java
``` java
package seedu.todolist.logic.parser;

import static seedu.todolist.commons.core.Messages.MESSAGE_FILE_NOT_FOUND;

import java.io.File;
import java.text.ParseException;
import java.util.List;
import java.util.Optional;

import seedu.todolist.logic.commands.Command;
import seedu.todolist.logic.commands.IncorrectCommand;
import seedu.todolist.logic.commands.SaveFileCommand;
/**
 * Parses input arguments and creates a new SaveFileCommand object
 */
public class SaveFileCommandParser {
    /**
     * Parses the given {@code String} of arguments in the context of the SaveFileCommand
     * and returns a SaveFileCommand object for execution.
     * @throws ParseException
     */
    public Command parse(String args) {
        ArgumentTokenizer argsTokenizer = new ArgumentTokenizer();
        argsTokenizer.tokenize(args);
        List<Optional<String>> preambleFields = ParserUtil.splitPreamble(argsTokenizer.getPreamble().orElse(null), 1);
        String saveFilePath = preambleFields.get(0).get();
        File saveFile = new File(saveFilePath);

        if (!saveFile.isFile()) {
            return new IncorrectCommand(String.format(MESSAGE_FILE_NOT_FOUND));
        }

        return new SaveFileCommand(saveFilePath);
    }
}
```
###### \java\seedu\todolist\model\ModelManager.java
``` java
    @Override
    public void updateFilteredTodoList(UniqueTagList tags) {
        updateFilteredTodoList(new PredicateExpression(new NameQualifier(tags)));
    }
```
###### \java\seedu\todolist\model\ModelManager.java
``` java
    private class NameQualifier implements Qualifier {
        private Set<String> nameKeyWords;
        private Set<Tag> tags;
        private Set<String> tagKeyWords;

        NameQualifier(Set<String> nameKeyWords) {
            this.nameKeyWords = nameKeyWords;
        }

        // In order for Java to overload the NameQualifier constructor
        // the parameter cannot be of type Set so use UniqueTagList instead
        NameQualifier(UniqueTagList tags) {
            this.tags = tags.toSet();

            // for simplicity sake, convert the Set<Tag> into Set<String> so that it can easily be filtered out
            // similar to filtering out by name
            this.tagKeyWords = new HashSet<String>();

            for (Tag tag:tags) {
                this.tagKeyWords.add(tag.tagName);
            }
        }

        @Override
        public boolean run(ReadOnlyTodo todo) {
            if (nameKeyWords != null) {
                String name = todo.getName().fullName;
                return nameKeyWords.stream()
                        .filter(keyword -> StringUtil.containsWordIgnoreCase(name, keyword))
                        .findAny()
                        .isPresent();
            } else {
                String todoTags = todo.getTagsAsString();
                return tagKeyWords.stream()
                        .filter(keyword -> StringUtil.containsWordIgnoreCase(todoTags, keyword))
                        .findAny()
                        .isPresent();
            }
        }

        /**
         * Returns the tags or the name of the todo depending on which field is present
         */
        @Override
        public String toString() {
            if (!tags.isEmpty()) {
                return "tag=" + String.join(", ", tagKeyWords);
            } else {
                return "name=" + String.join(", ", nameKeyWords);
            }
        }
    }
```
###### \java\seedu\todolist\model\tag\UniqueTagList.java
``` java
    public boolean isEmpty() {
        return this.internalList.isEmpty();
    }
```
###### \java\seedu\todolist\model\todo\ReadOnlyTodo.java
``` java
    /**
     * Formats the todo as text, showing all todo details.
     */
    default String getAsText() {
        final StringBuilder builder = new StringBuilder();

        builder.append(getName());

        if (getStartTime() != null) {
            builder.append(" Start: ")
                .append(getStartTime());
        }

        if (getEndTime() != null) {
            builder.append(" End: ")
                .append(getEndTime());
        }

        if (getCompleteTime() != null) {
            builder.append(" Complete: ")
                .append(getCompleteTime());
        }

        builder.append(" Tags: ");
        builder.append(getTagsAsString());

        return builder.toString();
    }
```
###### \java\seedu\todolist\model\todo\ReadOnlyTodo.java
``` java
    /**
     *  Formats the todo's tags as a string
     */
    default String getTagsAsString() {
        final StringBuilder builder = new StringBuilder();

        for (Tag tag:getTags()) {
            builder.append(tag.tagName + " ");
        }

        return builder.toString();
    }
```
###### \java\seedu\todolist\storage\StorageManager.java
``` java
    /** Raises an event to indicate the save file path has changed */
    private void indicateSaveFilePathChanged(String saveFilePath) {
        raise(new SaveFilePathChangedEvent(saveFilePath));
    }
```
###### \java\seedu\todolist\storage\StorageManager.java
``` java
    public void updateSaveFilePath(String saveFilePath) throws DataConversionException, IOException {
        logger.fine("Attempting to update save file: " + saveFilePath);

        try {
            // There should only be one instance of config each session - grab a
            // handle on that specific one
            Config config = ConfigUtil.readConfig(Config.DEFAULT_CONFIG_FILE).get();
            config.setTodoListFilePath(saveFilePath);

            // Update config file in case it was missing to begin with or there
            // are new/unused fields
            ConfigUtil.saveConfig(config, Config.DEFAULT_CONFIG_FILE);
            indicateSaveFilePathChanged(saveFilePath);
        } catch (DataConversionException e) {
            throw new DataConversionException(e);
        } catch (IOException e) {
            throw new IOException(e);
        }
    }
```
###### \java\seedu\todolist\storage\StorageManager.java
``` java
    @Override
    @Subscribe
    public void handleSaveFilePathChangedEvent(SaveFilePathChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event, "Save file location changed"));
    }
```
###### \java\seedu\todolist\ui\StatusBarFooter.java
``` java
    @Subscribe
    public void handleSaveFileChangedEvent(SaveFilePathChangedEvent evt) {
        String lastUpdated = (new Date()).toString();
        setSaveLocation(evt.saveFilePath);
        logger.info(LogsCenter.getEventHandlingLogMessage(evt, "Setting last updated status to " + lastUpdated));
        setSyncStatus("Last Updated: " + lastUpdated);
    }
```
