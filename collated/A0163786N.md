# A0163786N
###### /src/main/java/seedu/address/commons/util/StringUtil.java
``` java
    /**
     * Parses a Date from a string
     * @param s String to parse
     * @param dateFormat Format to use to parse string
     * @return Date object
     */
    public static Date parseDate(String s, String dateFormat) throws IllegalValueException {
        try {
            return new SimpleDateFormat(dateFormat).parse(s);
        } catch (ParseException e) {
            throw new IllegalValueException("Date must be entered as: " + dateFormat);
        }
    }
}
```
###### /src/main/java/seedu/address/logic/commands/CompleteCommand.java
``` java
    public static final String COMMAND_WORD = "complete";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Completes todo.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 1";

    public static final String MESSAGE_COMPLETE_TODO_SUCCESS = "Completed Todo: %1$s";

    public static final String MESSAGE_TODO_ALREADY_COMPLETE = "This todo is already complete";

    public static final String COMPLETE_TIME_FORMAT = "h:mma dd/MM/yyyy";

    public final int filteredTodoListIndex;
    public final Date completeTime;

    public CompleteCommand(int targetIndex) {
        // convert index from 1 based to 0 based
        this.filteredTodoListIndex = targetIndex - 1;
        this.completeTime = new Date();
    }

    public CompleteCommand(int targetIndex, String completeTime) throws IllegalValueException {
     // convert index from 1 based to 0 based
        this.filteredTodoListIndex = targetIndex - 1;
        this.completeTime = StringUtil.parseDate(completeTime, COMPLETE_TIME_FORMAT);
    }

    @Override
    public CommandResult execute() throws CommandException {

        UnmodifiableObservableList<ReadOnlyTodo> lastShownList = model.getFilteredTodoList();

        if (lastShownList.size() <= filteredTodoListIndex) {
            throw new CommandException(Messages.MESSAGE_INVALID_TODO_DISPLAYED_INDEX);
        }

        ReadOnlyTodo todoToComplete = lastShownList.get(filteredTodoListIndex);

        if (todoToComplete.getCompleteTime() != null) {
            throw new CommandException(MESSAGE_TODO_ALREADY_COMPLETE);
        }

        model.completeTodo(filteredTodoListIndex, completeTime);

        return new CommandResult(String.format(MESSAGE_COMPLETE_TODO_SUCCESS, todoToComplete));
    }

}
```
###### /src/main/java/seedu/address/logic/commands/UncompleteCommand.java
``` java
    public static final String COMMAND_WORD = "uncomplete";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Uncompletes todo.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 1";

    public static final String MESSAGE_UNCOMPLETE_TODO_SUCCESS = "Uncompleted Todo: %1$s";

    public static final String MESSAGE_TODO_NOT_COMPLETE = "This todo is not complete";

    public final int filteredTodoListIndex;

    public UncompleteCommand(int targetIndex) {
        // convert index from 1 based to 0 based
        this.filteredTodoListIndex = targetIndex - 1;
    }

    @Override
    public CommandResult execute() throws CommandException {

        UnmodifiableObservableList<ReadOnlyTodo> lastShownList = model.getFilteredTodoList();

        if (lastShownList.size() <= filteredTodoListIndex) {
            throw new CommandException(Messages.MESSAGE_INVALID_TODO_DISPLAYED_INDEX);
        }

        ReadOnlyTodo todoToUncomplete = lastShownList.get(filteredTodoListIndex);

        if (todoToUncomplete.getCompleteTime() == null) {
            throw new CommandException(MESSAGE_TODO_NOT_COMPLETE);
        }

        model.uncompleteTodo(filteredTodoListIndex);

        return new CommandResult(String.format(MESSAGE_UNCOMPLETE_TODO_SUCCESS, todoToUncomplete));
    }

}
```
###### /src/main/java/seedu/address/logic/commands/UndoCommand.java
``` java
    public static final String COMMAND_WORD = "undo";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Undoes last action if it involves modifying a todo. ";

    public static final String MESSAGE_SUCCESS = "Last modifying action undone";

    public static final String MESSAGE_NO_ACTION = "Error: no modifying action to undo";

    @Override
    public CommandResult execute() throws CommandException {
        assert model != null;
        try {
            model.loadPreviousState();
            return new CommandResult(MESSAGE_SUCCESS);
        } catch (Model.NoPreviousStateException e) {
            throw new CommandException(MESSAGE_NO_ACTION);
        }
    }
}
```
###### /src/main/java/seedu/address/logic/parser/CompleteCommandParser.java
``` java
    /**
     * Parses the given {@code String} of arguments in the context of the CompleteCommand
     * and returns an CompleteCommand object for execution.
     */
    public Command parse(String args) {
        ArgumentTokenizer argsTokenizer = new ArgumentTokenizer();
        argsTokenizer.tokenize(args);
        List<Optional<String>> preambleFields = ParserUtil.splitPreamble(argsTokenizer.getPreamble().orElse(null), 2);
        Optional<Integer> index = preambleFields.get(0).flatMap(ParserUtil::parseIndex);
        if (!index.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, CompleteCommand.MESSAGE_USAGE));
        }
        Optional<String> completeTime = preambleFields.get(1);
        try {
            if (completeTime.isPresent()) {
                return new CompleteCommand(index.get(), completeTime.get());
            } else {
                return new CompleteCommand(index.get());
            }
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }

}
```
###### /src/main/java/seedu/address/logic/parser/UncompleteCommandParser.java
``` java
    /**
     * Parses the given {@code String} of arguments in the context of the UncompleteCommand
     * and returns an UncompleteCommand object for execution.
     */
    public Command parse(String args) {

        Optional<Integer> index = ParserUtil.parseIndex(args);
        if (!index.isPresent()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, UncompleteCommand.MESSAGE_USAGE));
        }

        return new UncompleteCommand(index.get());
    }

}
```
###### /src/main/java/seedu/address/model/ModelManager.java
``` java
    @Override
    public synchronized void completeTodo(int filteredTodoListIndex, Date completeTime) {
        TodoList tempTodoList = new TodoList(todoList);
        todoList.completeTodo(filteredTodoListIndex, completeTime);
        previousTodoList = tempTodoList;
        indicateTodoListChanged();
    }
```
###### /src/main/java/seedu/address/model/ModelManager.java
``` java
    @Override
    public synchronized void uncompleteTodo(int filteredTodoListIndex) {
        TodoList tempTodoList = new TodoList(todoList);
        todoList.uncompleteTodo(filteredTodoListIndex);
        previousTodoList = tempTodoList;
        indicateTodoListChanged();
    }
```
###### /src/main/java/seedu/address/model/ModelManager.java
``` java
    @Override
    public void loadPreviousState() throws NoPreviousStateException {
        if (previousTodoList == null) {
            throw new NoPreviousStateException();
        }
        resetData(previousTodoList);
        previousTodoList = null;
    }

    //=========== Filtered Todo List Accessors =============================================================

    @Override
    public UnmodifiableObservableList<ReadOnlyTodo> getFilteredTodoList() {
        return new UnmodifiableObservableList<>(filteredTodos);
    }

    @Override
    public void updateFilteredListToShowAll() {
        filteredTodos.setPredicate(null);
    }

    @Override
    public void updateFilteredTodoList(Set<String> keywords) {
        updateFilteredTodoList(new PredicateExpression(new NameQualifier(keywords)));
    }

    private void updateFilteredTodoList(Expression expression) {
        filteredTodos.setPredicate(expression::satisfies);
    }

    //========== Inner classes/interfaces used for filtering =================================================

    interface Expression {
        boolean satisfies(ReadOnlyTodo todo);
        String toString();
    }

    private class PredicateExpression implements Expression {

        private final Qualifier qualifier;

        PredicateExpression(Qualifier qualifier) {
            this.qualifier = qualifier;
        }

        @Override
        public boolean satisfies(ReadOnlyTodo todo) {
            return qualifier.run(todo);
        }

        @Override
        public String toString() {
            return qualifier.toString();
        }
    }

    interface Qualifier {
        boolean run(ReadOnlyTodo todo);
        String toString();
    }

    private class NameQualifier implements Qualifier {
        private Set<String> nameKeyWords;

        NameQualifier(Set<String> nameKeyWords) {
            this.nameKeyWords = nameKeyWords;
        }

        @Override
        public boolean run(ReadOnlyTodo todo) {
            return nameKeyWords.stream()
                    .filter(keyword -> StringUtil.containsWordIgnoreCase(todo.getName().fullName, keyword))
                    .findAny()
                    .isPresent();
        }

        @Override
        public String toString() {
            return "name=" + String.join(", ", nameKeyWords);
        }
    }

}
```
###### /src/main/java/seedu/address/model/todo/Todo.java
``` java
    /**
     * Constructor for a deadline
     */
    public Todo(Name name, Date endTime, UniqueTagList tags) {
        assert !CollectionUtil.isAnyNull(name, endTime, tags);
        this.name = name;
        this.endTime = endTime;
        this.tags = new UniqueTagList(tags); // protect internal tags from changes in the arg list
    }
```
###### /src/main/java/seedu/address/model/todo/Todo.java
``` java
    /**
     * Constructor for an event
     */
    public Todo(Name name, Date startTime, Date endTime, UniqueTagList tags) {
        assert !CollectionUtil.isAnyNull(name, startTime, endTime, tags);
        this.name = name;
        this.startTime = startTime;
        this.endTime = endTime;
        this.tags = new UniqueTagList(tags); // protect internal tags from changes in the arg list
    }
```
###### /src/main/java/seedu/address/model/todo/Todo.java
``` java
    public void setCompleteTime(Date completeTime) {
        this.completeTime = completeTime;
    }
```
###### /src/main/java/seedu/address/model/todo/Todo.java
``` java
    @Override
    public Date getCompleteTime() {
        return completeTime;
    }

    @Override
    public UniqueTagList getTags() {
        return new UniqueTagList(tags);
    }

    /**
     * Replaces this todo's tags with the tags in the argument tag list.
     */
    public void setTags(UniqueTagList replacement) {
        tags.setTags(replacement);
    }

    /**
     * Updates this todo with the details of {@code replacement}.
     */
    public void resetData(ReadOnlyTodo replacement) {
        assert replacement != null;

        this.setName(replacement.getName());
        this.setStartTime(replacement.getStartTime());
        this.setEndTime(replacement.getEndTime());
        this.setCompleteTime(replacement.getCompleteTime());
        this.setTags(replacement.getTags());
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ReadOnlyTodo // instanceof handles nulls
                && this.isSameStateAs((ReadOnlyTodo) other));
    }

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(name, startTime, endTime, completeTime, tags);
    }

    @Override
    public String toString() {
        return getAsText();
    }

}
```
###### /src/main/java/seedu/address/model/todo/UniqueTodoList.java
``` java
    /**
     * Completes the todo in the list at position {@code index} with {@code completeTime}
     */
    public void completeTodo(int index, Date completeTime) {
        Todo todoToComplete = internalList.get(index);
        todoToComplete.setCompleteTime(completeTime);
        internalList.set(index, todoToComplete);
    }
```
###### /src/main/java/seedu/address/model/todo/UniqueTodoList.java
``` java
    /**
     * Uncompletes the todo in the list at position {@code index}
     */
    public void uncompleteTodo(int index) {
        Todo todoToUncomplete = internalList.get(index);
        todoToUncomplete.setCompleteTime(null);
        internalList.set(index, todoToUncomplete);
    }

    /**
     * Removes the equivalent todo from the list.
     *
     * @throws TodoNotFoundException if no such todo could be found in the list.
     */
    public boolean remove(ReadOnlyTodo toRemove) throws TodoNotFoundException {
        assert toRemove != null;
        final boolean todoFoundAndDeleted = internalList.remove(toRemove);
        if (!todoFoundAndDeleted) {
            throw new TodoNotFoundException();
        }
        return todoFoundAndDeleted;
    }

    public void setTodos(UniqueTodoList replacement) {
        this.internalList.setAll(replacement.internalList);
    }

    public void setTodos(List<? extends ReadOnlyTodo> todos) throws DuplicateTodoException {
        final UniqueTodoList replacement = new UniqueTodoList();
        for (final ReadOnlyTodo todo : todos) {
            replacement.add(new Todo(todo));
        }
        setTodos(replacement);
    }

    public UnmodifiableObservableList<Todo> asObservableList() {
        return new UnmodifiableObservableList<>(internalList);
    }

    @Override
    public Iterator<Todo> iterator() {
        return internalList.iterator();
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof UniqueTodoList // instanceof handles nulls
                && this.internalList.equals(
                ((UniqueTodoList) other).internalList));
    }

    @Override
    public int hashCode() {
        return internalList.hashCode();
    }

    /**
     * Signals that an operation would have violated the 'no duplicates' property of the list.
     */
    public static class DuplicateTodoException extends DuplicateDataException {
        protected DuplicateTodoException() {
            super("Operation would result in duplicate todo");
        }
    }

    /**
     * Signals that an operation targeting a specified todo in the list would fail because
     * there is no such matching todo in the list.
     */
    public static class TodoNotFoundException extends Exception {}

}
```
###### /src/main/java/seedu/address/model/TodoList.java
``` java
    /**
     * Completes the todo in the list at position {@code index} with {@code completeTime}.
     */
    public void completeTodo(int index, Date completeTime) {
        todos.completeTodo(index, completeTime);
    }
```
###### /src/main/java/seedu/address/model/TodoList.java
``` java
    /**
     * Uncompletes the todo in the list at position {@code index}.
     */
    public void uncompleteTodo(int index) {
        todos.uncompleteTodo(index);
    }

    /**
     * Ensures that every tag in this todo:
     *  - exists in the master list {@link #tags}
     *  - points to a Tag object in the master list
     */
    private void syncMasterTagListWith(Todo todo) {
        final UniqueTagList todoTags = todo.getTags();
        tags.mergeFrom(todoTags);

        // Create map with values = tag object references in the master list
        // used for checking todo tag references
        final Map<Tag, Tag> masterTagObjects = new HashMap<>();
        tags.forEach(tag -> masterTagObjects.put(tag, tag));

        // Rebuild the list of todo tags to point to the relevant tags in the master tag list.
        final Set<Tag> correctTagReferences = new HashSet<>();
        todoTags.forEach(tag -> correctTagReferences.add(masterTagObjects.get(tag)));
        todo.setTags(new UniqueTagList(correctTagReferences));
    }

    /**
     * Ensures that every tag in these todos:
     *  - exists in the master list {@link #tags}
     *  - points to a Tag object in the master list
     *  @see #syncMasterTagListWith(Todo)
     */
    private void syncMasterTagListWith(UniqueTodoList todos) {
        todos.forEach(this::syncMasterTagListWith);
    }

    public boolean removeTodo(ReadOnlyTodo key) throws UniqueTodoList.TodoNotFoundException {
        if (todos.remove(key)) {
            return true;
        } else {
            throw new UniqueTodoList.TodoNotFoundException();
        }
    }

//// tag-level operations

    public void addTag(Tag t) throws UniqueTagList.DuplicateTagException {
        tags.add(t);
    }

//// util methods

    @Override
    public String toString() {
        return todos.asObservableList().size() + " todos, " + tags.asObservableList().size() +  " tags";
        // Todo: refine later
    }

    @Override
    public ObservableList<ReadOnlyTodo> getTodoList() {
        return new UnmodifiableObservableList<>(todos.asObservableList());
    }

    @Override
    public ObservableList<Tag> getTagList() {
        return new UnmodifiableObservableList<>(tags.asObservableList());
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof TodoList // instanceof handles nulls
                && this.todos.equals(((TodoList) other).todos)
                && this.tags.equalsOrderInsensitive(((TodoList) other).tags));
    }

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(todos, tags);
    }
}
```
###### /src/main/java/seedu/address/storage/XmlAdaptedTodo.java
``` java
    /**
     * Converts this jaxb-friendly adapted todo object into the model's Todo object.
     *
     * @throws IllegalValueException if there were any data constraints violated in the adapted todo
     */
    public Todo toModelType() throws IllegalValueException {
        final List<Tag> todoTags = new ArrayList<>();
        for (XmlAdaptedTag tag : tagged) {
            todoTags.add(tag.toModelType());
        }
        final Name name = new Name(this.name);
        final UniqueTagList tags = new UniqueTagList(todoTags);
        Date startTime = null;
        Date endTime = null;
        Date completeTime = null;
        if (!this.startTime.isEmpty()) {
            try {
                startTime = StringUtil.parseDate(this.startTime, "EEE MMM dd HH:mm:ss zzz yyyy");
            } catch (IllegalValueException e) {
                e.printStackTrace();
            }
        }
        if (!this.endTime.isEmpty()) {
            try {
                endTime = StringUtil.parseDate(this.endTime, "EEE MMM dd HH:mm:ss zzz yyyy");
            } catch (IllegalValueException e) {
                e.printStackTrace();
            }
        }
        if (!this.completeTime.isEmpty()) {
            try {
                completeTime = StringUtil.parseDate(this.completeTime, "EEE MMM dd HH:mm:ss zzz yyyy");
            } catch (IllegalValueException e) {
                e.printStackTrace();
            }
        }
        return new Todo(name, startTime, endTime, completeTime, tags);
    }
}
```
###### /src/main/java/seedu/address/ui/TodoCard.java
``` java
    public TodoCard(ReadOnlyTodo todo, int displayedIndex) {
        super(FXML);
        name.setText(todo.getName().fullName);
        id.setText(displayedIndex + ". ");
        if (todo.getStartTime() != null) {
            start.setText(String.format("Start: %1$s",
                    new SimpleDateFormat(AddCommand.DATE_FORMAT).format(todo.getStartTime())));
        }
        if (todo.getEndTime() != null) {
            end.setText(String.format("End: %1$s",
                    new SimpleDateFormat(AddCommand.DATE_FORMAT).format(todo.getEndTime())));
        }
        if (todo.getCompleteTime() != null) {
            complete.setText(String.format("Completed at %1$s",
                    new SimpleDateFormat(CompleteCommand.COMPLETE_TIME_FORMAT).format(todo.getCompleteTime())));
            complete.setStyle("-fx-text-fill: #00ad36;");
        } else {
            complete.setText("Not Complete");
            complete.setStyle("-fx-text-fill: #e20000;");
        }
        initTags(todo);
    }

    private void initTags(ReadOnlyTodo todo) {
        todo.getTags().forEach(tag -> tags.getChildren().add(new Label(tag.tagName)));
    }
}
```
###### /src/test/java/guitests/CompleteCommandTest.java
``` java
    /**
     * The list of todos in the todo list panel is expected to match this list
     */
    private TestTodo[] currentList;
    private String timeOfCompletion = "7:11PM 19/03/2017";

    @Before
    public void setUp() {
        currentList = td.getTypicalTodos();
    }

    @Test
    public void complete_validFloatingTaskNoTimeSpecified_success() {
        assertCompleteSuccess(1, currentList);
    }

    @Test
    public void complete_validDeadlineNoTimeSpecified_success() {

        assertCompleteSuccess(8, currentList);
    }

    @Test
    public void complete_validEventNoTimeSpecified_success() {
        assertCompleteSuccess(9, currentList);
    }

    @Test
    public void complete_validFloatingTaskTimeSpecified_success() {
        assertCompleteSuccess(1, timeOfCompletion, currentList);
    }

    @Test
    public void complete_validDeadlineTimeSpecified_success() {
        assertCompleteSuccess(8, timeOfCompletion, currentList);
    }

    @Test
    public void complete_validEventTimeSpecified_success() {
        assertCompleteSuccess(9, timeOfCompletion, currentList);
    }

    @Test
    public void complete_alreadyCompletedFloatingTask_failure() {
        commandBox.runCommand("complete 10");
        assertResultMessage("This todo is already complete");
    }

    @Test
    public void complete_alreadyCompletedDeadline_failure() {
        commandBox.runCommand("complete 11");
        assertResultMessage("This todo is already complete");
    }

    @Test
    public void complete_alreadyCompletedEvent_failure() {
        commandBox.runCommand("complete 12");
        assertResultMessage("This todo is already complete");
    }

    @Test
    public void complete_invalidTime_failure() {
        commandBox.runCommand("complete 1 invalidDateString");
        assertResultMessage("Date must be entered as: " + CompleteCommand.COMPLETE_TIME_FORMAT);
    }

    @Test
    public void complete_invalidCommand_failure() {
        commandBox.runCommand("completes 1");
        assertResultMessage(Messages.MESSAGE_UNKNOWN_COMMAND);
    }

    @Test
    public void complete_invalidIndex_failure() {
        int invalidIndex = currentList.length + 1;
        commandBox.runCommand("complete " + invalidIndex);
        assertResultMessage(Messages.MESSAGE_INVALID_TODO_DISPLAYED_INDEX);
    }

    /**
     * Runs the complete command to complete the todo at specified index and confirms the result is correct.
     * @param targetIndexOneIndexed e.g. index 1 to complete the first todo in the list,
     * @param currentList A copy of the current list of todos (before completion).
     */
    private void assertCompleteSuccess(int targetIndexOneIndexed, final TestTodo[] currentList) {
        TestTodo[] completedTodoList = TestUtil.completeTodoInList(currentList, targetIndexOneIndexed,
            timeOfCompletion);

        commandBox.runCommand("complete " + targetIndexOneIndexed);

        //confirm the list now shows the todo as completed
        assertTrue(todoListPanel.isListMatching(false, completedTodoList));
    }

    /**
     * Runs the complete command to complete the todo at specified index and time and confirms the result is correct.
     * @param targetIndexOneIndexed e.g. index 1 to complete the first todo in the list,
     * @param completeTime Time that todo is to be completed;
     * @param currentList A copy of the current list of todos (before completion).
     */
    private void assertCompleteSuccess(int targetIndexOneIndexed,
            String completeTime, final TestTodo[] currentList) {
        TestTodo todoToComplete = currentList[targetIndexOneIndexed - 1]; // -1 as array uses zero indexing
        TestTodo[] completedTodoList = TestUtil.completeTodoInList(currentList, targetIndexOneIndexed, completeTime);

        commandBox.runCommand("complete " + targetIndexOneIndexed + " " + completeTime);

        //confirm the list now shows the todo as completed
        assertTrue(todoListPanel.isListMatching(true, completedTodoList));

        //confirm the result message is correct
        assertResultMessage(String.format(MESSAGE_COMPLETE_TODO_SUCCESS, todoToComplete));
    }
}
```
###### /src/test/java/guitests/guihandles/TodoCardHandle.java
``` java
    private String getCompleteTime() {
        return getTextFromLabel(COMPLETETIME_FIELD_ID);
    }
```
###### /src/test/java/guitests/guihandles/TodoCardHandle.java
``` java
    public boolean isSameTodo(ReadOnlyTodo todo, boolean checkCompleteTime) {
        if (checkCompleteTime) {
            DateFormat completeCommandDateFormat = new SimpleDateFormat(CompleteCommand.COMPLETE_TIME_FORMAT);
            if (todo.getCompleteTime() != null && !getCompleteTime().equals("Completed at "
                + completeCommandDateFormat.format(todo.getCompleteTime()))) {
                return false;
            }
        }
        return isSameTodo(todo);
    }
```
###### /src/test/java/guitests/guihandles/TodoCardHandle.java
``` java
    public boolean isSameTodo(ReadOnlyTodo todo) {
        DateFormat addCommandDateFormat = new SimpleDateFormat(AddCommand.DATE_FORMAT);
        if (todo.getStartTime() != null
                && !getStartTime().equals("Start: " + addCommandDateFormat.format(todo.getStartTime()))) {
            return false;
        }
        if (todo.getEndTime() != null
            && !getEndTime().equals("End: " + addCommandDateFormat.format(todo.getEndTime()))) {
            return false;
        }
        if (todo.getCompleteTime() != null && getCompleteTime().equals("Not Complete")) {
            return false;
        }
        return getFullName().equals(todo.getName().fullName) && getTags().equals(getTags(todo.getTags()));
    }

    @Override
    public boolean equals(Object obj) {
        if (obj instanceof TodoCardHandle) {
            TodoCardHandle handle = (TodoCardHandle) obj;
            return getFullName().equals(handle.getFullName())
                    && getTags().equals(handle.getTags());
        }
        return super.equals(obj);
    }

    @Override
    public String toString() {
        return getFullName();
    }
}
```
###### /src/test/java/guitests/UncompleteCommandTest.java
``` java
    /**
     * The list of todos in the todo list panel is expected to match this list
     */
    private TestTodo[] currentList;

    @Before
    public void setUp() {
        currentList = td.getTypicalTodos();
    }

    @Test
    public void ununcomplete_validFloatingTodo_success() {
        assertUncompleteSuccess(10, currentList);
    }

    @Test
    public void uncomplete_validDeadline_success() {
        assertUncompleteSuccess(11, currentList);
    }

    @Test
    public void uncomplete_validEvent_success() {
        assertUncompleteSuccess(12, currentList);
    }

    @Test
    public void uncomplete_notCompletedFloatingTask_failure() {
        commandBox.runCommand("uncomplete 7");
        assertResultMessage("This todo is not complete");
    }

    @Test
    public void uncomplete_notCompletedDeadline_failure() {
        commandBox.runCommand("uncomplete 8");
        assertResultMessage("This todo is not complete");
    }

    @Test
    public void uncomplete_notCompletedEvent_failure() {
        commandBox.runCommand("uncomplete 9");
        assertResultMessage("This todo is not complete");
    }

    @Test
    public void uncomplete_invalidCommand_failure() {
        commandBox.runCommand("uncompletes 1");
        assertResultMessage(Messages.MESSAGE_UNKNOWN_COMMAND);
    }

    @Test
    public void uncomplete_invalidIndex_failure() {
        int invalidIndex = currentList.length + 1;
        commandBox.runCommand("uncomplete " + invalidIndex);
        assertResultMessage(Messages.MESSAGE_INVALID_TODO_DISPLAYED_INDEX);
    }

    /**
     * Runs the uncomplete command to uncomplete the todo at specified index and confirms the result is correct.
     * @param targetIndexOneIndexed e.g. index 1 to uncomplete the first todo in the list,
     * @param currentList A copy of the current list of todos (before uncompletion).
     */
    private void assertUncompleteSuccess(int targetIndexOneIndexed, final TestTodo[] currentList) {
        TestTodo[] uncompletedTodoList = TestUtil.uncompleteTodoInList(currentList, targetIndexOneIndexed);

        commandBox.runCommand("uncomplete " + targetIndexOneIndexed);

        //confirm the list now shows the todo as uncompleted
        assertTrue(todoListPanel.isListMatching(false, uncompletedTodoList));
    }
}
```
###### /src/test/java/guitests/UndoCommandTest.java
``` java
    /**
     * The list of todos in the todo list panel is expected to match this list
     */
    private TestTodo[] originalList = td.getTypicalTodos();

    @Test
    public void undo_noActionToUndo_failure() {
        commandBox.runCommand(UndoCommand.COMMAND_WORD);
        assertResultMessage(UndoCommand.MESSAGE_NO_ACTION);
    }

    @Test
    public void undo_listTodos_failure() {
        commandBox.runCommand("list");
        commandBox.runCommand(UndoCommand.COMMAND_WORD);
        assertResultMessage(UndoCommand.MESSAGE_NO_ACTION);
    }

    @Test
    public void undo_addValidFloatingTask_success() {
        commandBox.runCommand(td.laundry.getAddCommand());
        assertUndoSuccess();
    }

    @Test
    public void undo_addValidDeadline_success() {
        commandBox.runCommand(td.job.getAddCommand());
        assertUndoSuccess();
    }

    @Test
    public void undo_addValidEvent_success() {
        commandBox.runCommand(td.lunch.getAddCommand());
        assertUndoSuccess();
    }

    @Test
    public void undo_deleteValidTodo_success() {
        commandBox.runCommand("delete 1");
        assertUndoSuccess();
    }

    @Test
    public void undo_clearTodos_success() {
        commandBox.runCommand("clear");
        assertUndoSuccess();
    }

    @Test
    public void undo_editValidTodo_success() {
        commandBox.runCommand("edit 1 Feed the dog");
        assertUndoSuccess();
    }

    @Test
    public void undo_completeValidTodo_success() {
        commandBox.runCommand("complete 1");
        assertUndoSuccess();
    }

    @Test
    public void undo_uncompleteValidTodo_success() {
        commandBox.runCommand("uncomplete 10");
        assertUndoSuccess();
    }

    @Test
    public void undo_invalidCommand_failure() {
        commandBox.runCommand("undoes");
        assertResultMessage(Messages.MESSAGE_UNKNOWN_COMMAND);
    }

    /**
     * Runs undo command and asserts resulting list matches currentList
     * @param currentList
     */
    private void assertUndoSuccess() {
        commandBox.runCommand(UndoCommand.COMMAND_WORD);
        // confirm the list now contains all previous todos
        assertTrue(todoListPanel.isListMatching(true, originalList));
        assertResultMessage(UndoCommand.MESSAGE_SUCCESS);
    }
}
```
###### /src/test/java/seedu/address/commons/util/StringUtilTest.java
``` java
    @Test
    public void parseDate_emptyString_illegalValueException() throws IllegalValueException {
        thrown.expect(IllegalValueException.class);
        StringUtil.parseDate("", "dd/MM/yyyy");
    }
```
###### /src/test/java/seedu/address/commons/util/StringUtilTest.java
``` java
    @Test
    public void parseDate_noMatch_illegalValueException() throws IllegalValueException {
        thrown.expect(IllegalValueException.class);
        StringUtil.parseDate("asdf", "dd/MM/yyyy");
    }
```
###### /src/test/java/seedu/address/commons/util/StringUtilTest.java
``` java
    @Test
    public void parseDate_stringMatch_success() throws IllegalValueException, ParseException {
        String dateString = "08/08/2008";
        String dateFormat = "dd/MM/yyyy";
        assertEquals(StringUtil.parseDate(dateString, dateFormat),
                new SimpleDateFormat(dateFormat).parse(dateString));
    }

}
```
###### /src/test/java/seedu/address/testutil/TestTodo.java
``` java
    /**
     * Constructor for a deadline
     */
    public TestTodo(Name name, Date endtime, UniqueTagList tags) {
        assert !CollectionUtil.isAnyNull(name);
        this.name = name;
        if (endtime != null) {
            this.endtime = endtime;
        }
        this.tags = new UniqueTagList(tags); // protect internal tags from changes in the arg list
    }

    /**
     * Constructor for an event
     */
    public TestTodo(Name name, Date starttime, Date endtime, UniqueTagList tags) {
        assert !CollectionUtil.isAnyNull(name);
        this.name = name;
        if (starttime != null && endtime != null) {
            this.starttime = starttime;
            this.endtime = endtime;
        }
        this.tags = new UniqueTagList(tags); // protect internal tags from changes in the arg list
    }
```
###### /src/test/java/seedu/address/testutil/TestTodo.java
``` java
    /**
     * General todo constructor
     */
    public TestTodo(Name name, Date starttime, Date endtime, Date completeTime, UniqueTagList tags) {
        this.name = name;
        this.starttime = starttime;
        this.endtime = endtime;
        this.completeTime = completeTime;
        this.tags = new UniqueTagList(tags); // protect internal tags from changes in the arg list
    }

    /**
     * Creates a copy of the given ReadOnlyTodo.
     */
    public TestTodo(ReadOnlyTodo source) {
        this(source.getName(), source.getStartTime(), source.getEndTime(), source.getCompleteTime(), source.getTags());
    }

    public void setName(Name name) {
        assert name != null;
        this.name = name;
    }

    @Override
    public Name getName() {
        return name;
    }

    public void setStartTime(Date starttime) {
        assert starttime != null;
        this.starttime = starttime;
    }

    @Override
    public Date getStartTime() {
        return starttime;
    }

    public void setEndTime(Date endtime) {
        assert endtime != null;
        this.endtime = endtime;
    }

    @Override
    public Date getEndTime() {
        return endtime;
    }
```
###### /src/test/java/seedu/address/testutil/TestTodo.java
``` java
    public void setCompleteTime(Date completeTime) {
        this.completeTime = completeTime;
    }
```
###### /src/test/java/seedu/address/testutil/TestTodo.java
``` java
    @Override
    public Date getCompleteTime() {
        return completeTime;
    }

    @Override
    public UniqueTagList getTags() {
        return new UniqueTagList(tags);
    }

    /**
     * Replaces this todo's tags with the tags in the argument tag list.
     */
    public void setTags(UniqueTagList replacement) {
        tags.setTags(replacement);
    }

    /**
     * Updates this todo with the details of {@code replacement}.
     */
    public void resetData(ReadOnlyTodo replacement) {
        assert replacement != null;

        this.setName(replacement.getName());
        this.setStartTime(replacement.getStartTime());
        this.setEndTime(replacement.getEndTime());
        this.setTags(replacement.getTags());
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ReadOnlyTodo // instanceof handles nulls
                && this.isSameStateAs((ReadOnlyTodo) other));
    }

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(name, starttime, endtime, tags);
    }

    @Override
    public String toString() {
        return getAsText();
    }
```
###### /src/test/java/seedu/address/testutil/TestTodo.java
``` java
    public String getAddCommand() {
        StringBuilder sb = new StringBuilder();
        sb.append("add " + this.getName().fullName);
        if (this.getEndTime() != null) {
            DateFormat dateFormat = new SimpleDateFormat(AddCommand.DATE_FORMAT);
            sb.append(" e/" + dateFormat.format(this.getEndTime()));
            if (this.getStartTime() != null) {
                sb.append(" s/" + dateFormat.format(this.getStartTime()));
            }
        }

        this.getTags().asObservableList().stream().forEach(s -> sb.append(" t/" + s.tagName + " "));
        return sb.toString();
    }
}
```
###### /src/test/java/seedu/address/testutil/TestUtil.java
``` java
    /**
     * Completes the todo at targetIndexOneIndexedFormat
     * @param todos The list of todos
     * @param targetIndexOneIndexedFormat index of todo to be completed
     * @param completeTime
     * @return The modified todos after completing the specified todo.
     */
    public static TestTodo[] completeTodoInList(final TestTodo[] todos, int targetIndexOneIndexedFormat,
            String completeTime) {
        Date completeDate = null;
        try {
            completeDate = StringUtil.parseDate(completeTime, CompleteCommand.COMPLETE_TIME_FORMAT);
        } catch (IllegalValueException e) {
            e.printStackTrace();
            assert false : "invalid complete time format";
        }
        int index = targetIndexOneIndexedFormat - 1; //array is zero indexed
        TestTodo todoToComplete = todos[index];
        todoToComplete.setCompleteTime(completeDate);
        return replaceTodoFromList(todos, todoToComplete, index);
    }
```
###### /src/test/java/seedu/address/testutil/TestUtil.java
``` java
    /**
     * Uncompletes the todo at targetIndexOneIndexedFormat
     * @param todos The list of todos
     * @param targetIndexOneIndexedFormat index of todo to be uncompleted
     * @return The modified todos after uncompleting the specified todo.
     */
    public static TestTodo[] uncompleteTodoInList(final TestTodo[] todos, int targetIndexOneIndexedFormat) {
        int index = targetIndexOneIndexedFormat - 1; //array is zero indexed
        TestTodo todoToUncomplete = todos[index];
        todoToUncomplete.setCompleteTime(null);
        return replaceTodoFromList(todos, todoToUncomplete, index);
    }

    public static boolean compareCardAndTodo(TodoCardHandle card, ReadOnlyTodo todo, boolean compareCompleteTime) {
        return card.isSameTodo(todo, compareCompleteTime);
    }

    public static Tag[] getTagList(String tags) {
        if ("".equals(tags)) {
            return new Tag[]{};
        }

        final String[] split = tags.split(", ");

        final List<Tag> collect = Arrays.asList(split).stream().map(e -> {
            try {
                return new Tag(e.replaceFirst("Tag: ", ""));
            } catch (IllegalValueException e1) {
                //not possible
                assert false;
                return null;
            }
        }).collect(Collectors.toList());

        return collect.toArray(new Tag[split.length]);
    }

```
###### /src/test/java/seedu/address/testutil/TodoBuilder.java
``` java
    public TodoBuilder withCompleteTime(String strDateTime) throws IllegalValueException {
        try {
            this.todo.setCompleteTime(StringUtil.parseDate(strDateTime, AddCommand.DATE_FORMAT));
            return this;
        } catch (IllegalValueException e) {
            e.printStackTrace();
        }
        return null;
    }

    public TodoBuilder withTags(String ... tags) throws IllegalValueException {
        UniqueTagList tempList = new UniqueTagList();
        for (String tag: tags) {
            tempList.add(new Tag(tag));
        }
        todo.setTags(tempList);
        return this;
    }

    public TestTodo build() {
        return this.todo;
    }

}
```
###### /src/test/java/seedu/address/testutil/TypicalTestTodos.java
``` java
    public TypicalTestTodos() {
        try {
            dog = new TodoBuilder().withName("Walk the dog")
                    .withTags("petcare").build();
            cat = new TodoBuilder().withName("Walk the cat")
                    .withTags("petcare", "cat").build();
            math = new TodoBuilder().withName("Do math homework").build();
            english = new TodoBuilder().withName("Do english homework").build();
            dishes = new TodoBuilder().withName("Wash dishes").build();
            lawn = new TodoBuilder().withName("Mow the lawn").build();
            dinner = new TodoBuilder().withName("Cook dinner").build();
            essay = new TodoBuilder().withName("Write essay").withEndTime("6:00PM 11/11/2017").build();
            toilet = new TodoBuilder().withName("Go to the bathroom").withStartTime("12:00PM 11/11/2017")
                    .withEndTime("1:00PM 11/11/2017").build();
            car = new TodoBuilder().withName("Wash car").withCompleteTime("6:00PM 11/11/2017").build();
            library = new TodoBuilder().withName("Return library book").withEndTime("6:00PM 11/11/2017")
                    .withCompleteTime("6:00PM 11/11/2017").build();
            tennis = new TodoBuilder().withName("Play tennis").withStartTime("12:00PM 11/11/2017")
                    .withEndTime("1:00PM 11/11/2017").withCompleteTime("6:00PM 11/11/2017").build();
            // Manually added
            shopping = new TodoBuilder().withName("Go shopping").build();
            laundry = new TodoBuilder().withName("Do laundry").build();
            job = new TodoBuilder().withName("Apply to job").withEndTime("6:00PM 11/11/2017").build();
            lunch = new TodoBuilder().withName("lunch").withStartTime("12:00PM 11/11/2017")
                    .withEndTime("1:00PM 11/11/2017").build();
        } catch (IllegalValueException e) {
            e.printStackTrace();
            assert false : "not possible";
        }
    }

    public static void loadTodoListWithSampleData(TodoList ab) {
        for (TestTodo todo : new TypicalTestTodos().getTypicalTodos()) {
            try {
                ab.addTodo(new Todo(todo));
            } catch (UniqueTodoList.DuplicateTodoException e) {
                assert false : "not possible";
            }
        }
    }

    public TestTodo[] getTypicalTodos() {
        return new TestTodo[] { dog, cat, math, english, dishes, lawn, dinner, essay, toilet, car, library, tennis};
    }

    public TodoList getTypicalTodoList() {
        TodoList ab = new TodoList();
        loadTodoListWithSampleData(ab);
        return ab;
    }
}
```
